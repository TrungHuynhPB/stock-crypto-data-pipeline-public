name: dbt Local CI

on:
  # Designed to be run manually and via VS Code Local GitHub Actions
  workflow_dispatch:

jobs:
  dbt-test-local:
    runs-on: ubuntu-latest
    # Note: Secrets should be provided via act's --secret-file or environment variables
    env:
      PROJECT_DIR: .
      DBT_PROFILES_DIR: ./profiles
      SNOWFLAKE_ACCOUNT: ${{ secrets.SNOWFLAKE_ACCOUNT }}
      SNOWFLAKE_WAREHOUSE: ${{ secrets.SNOWFLAKE_WAREHOUSE }}
      SNOWFLAKE_DATABASE: ${{ secrets.SNOWFLAKE_DATABASE }}
      SNOWFLAKE_ROLE: ${{ secrets.SNOWFLAKE_ROLE }}
      SNOWFLAKE_SCHEMA: ${{ secrets.SNOWFLAKE_SCHEMA }}
      SNOWFLAKE_USER: ${{ secrets.SNOWFLAKE_USER }}
      SNOWFLAKE_USER_PRIVATE_KEY: ${{ secrets.SNOWFLAKE_USER_PRIVATE_KEY }}
      TRINO_HOST: ${{ secrets.TRINO_HOST }}
      TRINO_PORT: ${{ secrets.TRINO_PORT }}
      TRINO_USER: ${{ secrets.TRINO_USER }}
      TRINO_CATALOG: ${{ secrets.TRINO_CATALOG }}
      TRINO_SCHEMA: ${{ secrets.TRINO_SCHEMA }}
      TRINO_HTTP_SCHEME: ${{ secrets.TRINO_HTTP_SCHEME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for state comparison

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: "pyproject.toml"

      - name: Install uv and enable caching
        uses: astral-sh/setup-uv@v1
        with:
          enable-cache: true

      - name: Install the project
        run: uv sync --all-extras --dev
        working-directory: ${{ env.PROJECT_DIR }}

      - name: Run dbt deps
        run: uv run dbt deps
        working-directory: ${{ env.PROJECT_DIR }}

      - name: Generate baseline state from main branch
        run: |
          mkdir -p target/state
          # NOTE: When running via `act`, we generally won't have GitHub credentials inside the container.
          # Avoid `git fetch origin main` (which prompts for credentials) and instead:
          # - Prefer local `main` if present
          # - Otherwise prefer `origin/main` if present
          # - Otherwise skip baseline generation and continue in "no-state" mode
          if git show-ref --verify --quiet refs/heads/main; then
            BASE_REF="main"
          elif git show-ref --verify --quiet refs/remotes/origin/main; then
            BASE_REF="origin/main"
          else
            BASE_REF=""
          fi

          if [ -n "$BASE_REF" ]; then
            echo "Using baseline ref: $BASE_REF"
            # Save current branch name
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            
            # Stash any uncommitted changes before checking out (common in local `act` runs)
            # Use --include-untracked to catch files like uv.lock that might be modified
            if ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
              echo "Stashing local changes before baseline generation..."
              git stash push --include-untracked -m "act: stash for baseline generation"
              STASHED=true
            else
              STASHED=false
            fi
            
            # Use -f (force) to overwrite any conflicting files since we're in a container
            # The original files are safe on the host machine
            git checkout -f "$BASE_REF" --quiet
            uv run dbt parse --target ci-snowflake
            cp target/manifest.json target/state/manifest.json
            
            # Return to original branch (force checkout to handle any conflicts)
            git checkout -f "$CURRENT_BRANCH" --quiet
            
            # Restore stashed changes if we stashed them
            if [ "$STASHED" = "true" ]; then
              echo "Restoring stashed changes..."
              git stash pop --quiet || true
            fi
          else
            echo "No local baseline ref (main/origin/main) found; skipping state baseline generation."
            # Leave target/state empty; downstream steps should handle this gracefully.
          fi
        working-directory: ${{ env.PROJECT_DIR }}

      - name: Parse current branch for both targets
        run: |
          echo "Parsing with ci-snowflake target..."
          uv run dbt parse --target ci-snowflake
          echo "Parsing with ci-trino target..."
          uv run dbt parse --target ci-trino
        working-directory: ${{ env.PROJECT_DIR }}

      - name: SQLFLUFF - Lint modified SQL files only
        run: |
          # Avoid network fetches in local `act` runs.
          if git show-ref --verify --quiet refs/heads/main; then
            DIFF_BASE="main"
          elif git show-ref --verify --quiet refs/remotes/origin/main; then
            DIFF_BASE="origin/main"
          else
            DIFF_BASE=""
          fi

          if [ -n "$DIFF_BASE" ]; then
            # Get modified SQL files and filter out deleted files (only lint files that exist)
            FILES=$(git diff --name-only --diff-filter=d "$DIFF_BASE"...HEAD | grep -E '\.sql$' || true)
          else
            # Fall back to linting all SQL files (best-effort) if we can't compute a diff base.
            FILES=$(git ls-files '*.sql' || true)
          fi
          if [ -n "$FILES" ]; then
            echo "Linting modified SQL files:"
            echo "$FILES"
            uv run sqlfluff lint $FILES
          else
            echo "No SQL files changed"
          fi
        working-directory: ${{ env.PROJECT_DIR }}
        continue-on-error: false

      - name: Check for modified Trino models
        id: check-modified-trino
        run: |
          BASELINE_STATE_DIR=target/state
          
          if [ ! -f "$BASELINE_STATE_DIR/manifest.json" ]; then
            echo "No baseline manifest found at $BASELINE_STATE_DIR/manifest.json; skipping state-based selection."
            echo "has_models=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if there are any modified Trino models using state comparison with selector
          COUNT=$(uv run dbt ls \
            --select state:modified+ \
            --selector trino \
            --resource-type model \
            --state $BASELINE_STATE_DIR \
            --target ci-trino \
            --output name 2>/dev/null | \
            grep -vE '^(Running|Registered|Found|The selection|No nodes|Encountered)' | \
            grep -E '^[a-zA-Z_]' | wc -l || echo "0")
          echo "Modified Trino model count: $COUNT"
          if [ "$COUNT" -gt 0 ]; then
            echo "has_models=true" >> $GITHUB_OUTPUT
          else
            echo "has_models=false" >> $GITHUB_OUTPUT
          fi
        working-directory: ${{ env.PROJECT_DIR }}

      - name: Check for modified Snowflake models
        id: check-modified-snowflake
        run: |
          BASELINE_STATE_DIR=target/state
          
          if [ ! -f "$BASELINE_STATE_DIR/manifest.json" ]; then
            echo "No baseline manifest found at $BASELINE_STATE_DIR/manifest.json; skipping state-based selection."
            echo "has_models=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if there are any modified Snowflake models using state comparison with selector
          COUNT=$(uv run dbt ls \
            --select state:modified+ \
            --selector snowflake \
            --resource-type model \
            --state $BASELINE_STATE_DIR \
            --target ci-snowflake \
            --output name 2>/dev/null | \
            grep -vE '^(Running|Registered|Found|The selection|No nodes|Encountered)' | \
            grep -E '^[a-zA-Z_]' | wc -l || echo "0")
          echo "Modified Snowflake model count: $COUNT"
          if [ "$COUNT" -gt 0 ]; then
            echo "has_models=true" >> $GITHUB_OUTPUT
          else
            echo "has_models=false" >> $GITHUB_OUTPUT
          fi
        working-directory: ${{ env.PROJECT_DIR }}

      - name: Run dbt tests on modified Trino models
        if: steps.check-modified-trino.outputs.has_models == 'true'
        run: |
          BASELINE_STATE_DIR=target/state
          echo "Running dbt tests on modified Trino models"
          uv run dbt test \
            --select state:modified+ \
            --selector trino \
            --state $BASELINE_STATE_DIR \
            --target ci-trino
        working-directory: ${{ env.PROJECT_DIR }}

      - name: Run dbt tests on modified Snowflake models
        if: steps.check-modified-snowflake.outputs.has_models == 'true'
        run: |
          BASELINE_STATE_DIR=target/state
          echo "Running dbt tests on modified Snowflake models"
          uv run dbt test \
            --select state:modified+ \
            --selector snowflake \
            --state $BASELINE_STATE_DIR \
            --target ci-snowflake
        working-directory: ${{ env.PROJECT_DIR }}

      - name: Get modified model names for dbt-score
        id: modified-model-names
        run: |
          BASELINE_STATE_DIR=target/state
          
          if [ ! -f "$BASELINE_STATE_DIR/manifest.json" ]; then
            echo "No baseline manifest found; skipping dbt-score."
            echo "models=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get all modified model names (both Trino and Snowflake) for dbt-score
          # We'll combine results from both selectors
          TRINO_MODELS=$(uv run dbt ls \
            --select state:modified+ \
            --selector trino \
            --resource-type model \
            --state $BASELINE_STATE_DIR \
            --target ci-trino \
            --output name 2>/dev/null | \
            grep -vE '^(Running|Registered|Found|The selection|No nodes|Encountered)' | \
            grep -E '^[a-zA-Z_]' || echo "")
          
          SNOWFLAKE_MODELS=$(uv run dbt ls \
            --select state:modified+ \
            --selector snowflake \
            --resource-type model \
            --state $BASELINE_STATE_DIR \
            --target ci-snowflake \
            --output name 2>/dev/null | \
            grep -vE '^(Running|Registered|Found|The selection|No nodes|Encountered)' | \
            grep -E '^[a-zA-Z_]' || echo "")
          
          # Combine and deduplicate model names
          ALL_MODELS=$(echo -e "$TRINO_MODELS\n$SNOWFLAKE_MODELS" | sort -u | tr '\n' ' ' | xargs || echo "")
          
          if [ -n "$ALL_MODELS" ]; then
            echo "models=$ALL_MODELS" >> $GITHUB_OUTPUT
          else
            echo "models=" >> $GITHUB_OUTPUT
          fi
        working-directory: ${{ env.PROJECT_DIR }}

      - name: dbt-score - Lint modified models
        if: steps.modified-model-names.outputs.models != ''
        run: |
          MODELS="${{ steps.modified-model-names.outputs.models }}"
          echo "Running dbt-score lint on: $MODELS"
          # dbt-score internally calls dbt ls which needs a target via DBT_TARGET env var
          DBT_TARGET=ci-snowflake uv run dbt-score lint \
            -m target/manifest.json \
            --select "$MODELS"
        working-directory: ${{ env.PROJECT_DIR }}

